AWSTemplateFormatVersion: '2010-09-09'
Description: 'Lambda Functions Stack - Nested Stack'

Parameters:
  ProjectName:
    Type: String
    Description: Name of the project
  
  LambdaExecutionRoleArn:
    Type: String
    Description: ARN of the Lambda execution role
  
  S3BucketName:
    Type: String
    Description: Name of the S3 bucket
  
  DynamoDBTableName:
    Type: String
    Description: Name of the DynamoDB table

Resources:
  # Lambda function for image ingestion
  ImageIngestionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-image-ingestion'
      Runtime: python3.9
      Handler: image_ingestion.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import urllib.request
          import os
          from datetime import datetime
          import uuid
          
          s3_client = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}')) if isinstance(event.get('body'), str) else event
                  image_url = body.get('image_url')
                  metadata = body.get('metadata', {})
                  
                  if not image_url:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'image_url is required'})
                      }
                  
                  image_id = str(uuid.uuid4())
                  
                  with urllib.request.urlopen(image_url) as response:
                      image_data = response.read()
                  
                  file_extension = image_url.split('.')[-1].split('?')[0]
                  if file_extension not in ['jpg', 'jpeg', 'png', 'gif']:
                      file_extension = 'jpg'
                  
                  s3_key = f"images/{image_id}.{file_extension}"
                  
                  s3_client.put_object(
                      Bucket=os.environ['S3_BUCKET'],
                      Key=s3_key,
                      Body=image_data,
                      ContentType=f'image/{file_extension}'
                  )
                  
                  table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])
                  
                  item = {
                      'image_id': image_id,
                      's3_bucket': os.environ['S3_BUCKET'],
                      's3_key': s3_key,
                      'original_url': image_url,
                      'file_extension': file_extension,
                      'file_size': len(image_data),
                      'status': 'ingested',
                      'created_at': datetime.utcnow().isoformat(),
                      'updated_at': datetime.utcnow().isoformat()
                  }
                  
                  item.update(metadata)
                  table.put_item(Item=item)
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Image ingested successfully',
                          'image_id': image_id,
                          's3_location': f's3://{os.environ["S3_BUCKET"]}/{s3_key}'
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Environment:
        Variables:
          S3_BUCKET: !Ref S3BucketName
          DYNAMODB_TABLE: !Ref DynamoDBTableName

  # Lambda function for fetching images
  FetchImageFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-fetch-image'
      Runtime: python3.9
      Handler: fetch_image.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import base64
          
          s3_client = boto3.client('s3')
          
          def lambda_handler(event, context):
              try:
                  image_id = event.get('image_id')
                  
                  if not image_id:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'image_id is required'})
                      }
                  
                  extensions = ['jpg', 'jpeg', 'png', 'gif']
                  image_data = None
                  s3_key = None
                  
                  for ext in extensions:
                      try:
                          s3_key = f"images/{image_id}.{ext}"
                          response = s3_client.get_object(Bucket=os.environ['S3_BUCKET'], Key=s3_key)
                          image_data = response['Body'].read()
                          break
                      except s3_client.exceptions.NoSuchKey:
                          continue
                  
                  if image_data is None:
                      return {
                          'statusCode': 404,
                          'body': json.dumps({'error': f'Image {image_id} not found in S3'})
                      }
                  
                  image_base64 = base64.b64encode(image_data).decode('utf-8')
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'image_id': image_id,
                          's3_key': s3_key,
                          'image_data': image_base64,
                          'file_size': len(image_data)
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Environment:
        Variables:
          S3_BUCKET: !Ref S3BucketName

  # Lambda function for preprocessing
  PreprocessingFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-preprocessing'
      Runtime: python3.9
      Handler: preprocessing.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import base64
          import io
          from PIL import Image
          import numpy as np
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}')) if isinstance(event.get('body'), str) else event
                  image_data = body.get('image_data')
                  preprocessing_config = body.get('preprocessing_config', {})
                  
                  if not image_data:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'image_data is required'})
                      }
                  
                  image_bytes = base64.b64decode(image_data)
                  image = Image.open(io.BytesIO(image_bytes))
                  
                  if image.mode != 'RGB':
                      image = image.convert('RGB')
                  
                  processed_image = image.copy()
                  
                  if preprocessing_config.get('grayscale', False):
                      processed_image = processed_image.convert('L').convert('RGB')
                  
                  flip_type = preprocessing_config.get('flip')
                  if flip_type == 'horizontal':
                      processed_image = processed_image.transpose(Image.FLIP_LEFT_RIGHT)
                  elif flip_type == 'vertical':
                      processed_image = processed_image.transpose(Image.FLIP_TOP_BOTTOM)
                  
                  rotate_angle = preprocessing_config.get('rotate', 0)
                  if rotate_angle != 0:
                      processed_image = processed_image.rotate(rotate_angle, expand=True)
                  
                  resize_dimensions = preprocessing_config.get('resize')
                  if resize_dimensions and len(resize_dimensions) == 2:
                      processed_image = processed_image.resize(resize_dimensions, Image.Resampling.LANCZOS)
                  
                  buffer = io.BytesIO()
                  processed_image.save(buffer, format='JPEG')
                  processed_image_data = base64.b64encode(buffer.getvalue()).decode('utf-8')
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Image preprocessed successfully',
                          'processed_image_data': processed_image_data,
                          'original_size': image.size,
                          'processed_size': processed_image.size,
                          'preprocessing_applied': preprocessing_config
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # Lambda function for AlexNet inference
  AlexNetInferenceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-alexnet-inference'
      Runtime: python3.9
      Handler: alexnet_inference.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import base64
          import io
          import numpy as np
          from PIL import Image
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}')) if isinstance(event.get('body'), str) else event
                  image_data = body.get('processed_image_data')
                  
                  if not image_data:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'processed_image_data is required'})
                      }
                  
                  image_bytes = base64.b64decode(image_data)
                  image = Image.open(io.BytesIO(image_bytes))
                  
                  if image.mode != 'RGB':
                      image = image.convert('RGB')
                  
                  image = image.resize((224, 224), Image.Resampling.LANCZOS)
                  img_array = np.array(image) / 255.0
                  
                  np.random.seed(42)
                  mock_predictions = np.random.random(1000)
                  mock_predictions = mock_predictions / np.sum(mock_predictions)
                  
                  top_5_indices = np.argsort(mock_predictions)[-5:][::-1]
                  top_5_scores = mock_predictions[top_5_indices]
                  
                  class_names = [f"class_{i}" for i in range(1000)]
                  
                  predictions = []
                  for i, (idx, score) in enumerate(zip(top_5_indices, top_5_scores)):
                      predictions.append({
                          'rank': i + 1,
                          'class_id': int(idx),
                          'class_name': class_names[idx],
                          'confidence': float(score)
                      })
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'model': 'AlexNet',
                          'predictions': predictions,
                          'input_size': (224, 224),
                          'processing_time_ms': 150
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # Lambda function for ResNet inference
  ResNetInferenceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-resnet-inference'
      Runtime: python3.9
      Handler: resnet_inference.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import base64
          import io
          import numpy as np
          from PIL import Image
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}')) if isinstance(event.get('body'), str) else event
                  image_data = body.get('processed_image_data')
                  
                  if not image_data:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'processed_image_data is required'})
                      }
                  
                  image_bytes = base64.b64decode(image_data)
                  image = Image.open(io.BytesIO(image_bytes))
                  
                  if image.mode != 'RGB':
                      image = image.convert('RGB')
                  
                  image = image.resize((224, 224), Image.Resampling.LANCZOS)
                  img_array = np.array(image) / 255.0
                  
                  np.random.seed(43)
                  mock_predictions = np.random.random(1000)
                  mock_predictions = mock_predictions / np.sum(mock_predictions)
                  
                  top_5_indices = np.argsort(mock_predictions)[-5:][::-1]
                  top_5_scores = mock_predictions[top_5_indices]
                  
                  class_names = [f"class_{i}" for i in range(1000)]
                  
                  predictions = []
                  for i, (idx, score) in enumerate(zip(top_5_indices, top_5_scores)):
                      predictions.append({
                          'rank': i + 1,
                          'class_id': int(idx),
                          'class_name': class_names[idx],
                          'confidence': float(score)
                      })
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'model': 'ResNet',
                          'predictions': predictions,
                          'input_size': (224, 224),
                          'processing_time_ms': 200
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # Lambda function for MobileNet inference
  MobileNetInferenceFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-mobilenet-inference'
      Runtime: python3.9
      Handler: mobilenet_inference.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import base64
          import io
          import numpy as np
          from PIL import Image
          
          def lambda_handler(event, context):
              try:
                  body = json.loads(event.get('body', '{}')) if isinstance(event.get('body'), str) else event
                  image_data = body.get('processed_image_data')
                  
                  if not image_data:
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'processed_image_data is required'})
                      }
                  
                  image_bytes = base64.b64decode(image_data)
                  image = Image.open(io.BytesIO(image_bytes))
                  
                  if image.mode != 'RGB':
                      image = image.convert('RGB')
                  
                  image = image.resize((224, 224), Image.Resampling.LANCZOS)
                  img_array = np.array(image) / 255.0
                  
                  np.random.seed(44)
                  mock_predictions = np.random.random(1000)
                  mock_predictions = mock_predictions / np.sum(mock_predictions)
                  
                  top_5_indices = np.argsort(mock_predictions)[-5:][::-1]
                  top_5_scores = mock_predictions[top_5_indices]
                  
                  class_names = [f"class_{i}" for i in range(1000)]
                  
                  predictions = []
                  for i, (idx, score) in enumerate(zip(top_5_indices, top_5_scores)):
                      predictions.append({
                          'rank': i + 1,
                          'class_id': int(idx),
                          'class_name': class_names[idx],
                          'confidence': float(score)
                      })
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'model': 'MobileNet',
                          'predictions': predictions,
                          'input_size': (224, 224),
                          'processing_time_ms': 100
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # Lambda function for aggregating results
  AggregatorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-aggregator'
      Runtime: python3.9
      Handler: aggregator.lambda_handler
      Role: !Ref LambdaExecutionRoleArn
      Timeout: 300
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          
          dynamodb = boto3.resource('dynamodb')
          
          def lambda_handler(event, context):
              try:
                  alexnet_result = event[0]
                  resnet_result = event[1]
                  mobilenet_result = event[2]
                  
                  alexnet_data = json.loads(alexnet_result.get('body', '{}'))
                  resnet_data = json.loads(resnet_result.get('body', '{}'))
                  mobilenet_data = json.loads(mobilenet_result.get('body', '{}'))
                  
                  aggregated_results = {
                      'alexnet': {
                          'model': alexnet_data.get('model'),
                          'top_prediction': alexnet_data.get('predictions', [{}])[0] if alexnet_data.get('predictions') else {},
                          'processing_time_ms': alexnet_data.get('processing_time_ms', 0)
                      },
                      'resnet': {
                          'model': resnet_data.get('model'),
                          'top_prediction': resnet_data.get('predictions', [{}])[0] if resnet_data.get('predictions') else {},
                          'processing_time_ms': resnet_data.get('processing_time_ms', 0)
                      },
                      'mobilenet': {
                          'model': mobilenet_data.get('model'),
                          'top_prediction': mobilenet_data.get('predictions', [{}])[0] if mobilenet_data.get('predictions') else {},
                          'processing_time_ms': mobilenet_data.get('processing_time_ms', 0)
                      }
                  }
                  
                  predictions = [
                      alexnet_data.get('predictions', [{}])[0].get('class_name', 'unknown') if alexnet_data.get('predictions') else 'unknown',
                      resnet_data.get('predictions', [{}])[0].get('class_name', 'unknown') if resnet_data.get('predictions') else 'unknown',
                      mobilenet_data.get('predictions', [{}])[0].get('class_name', 'unknown') if mobilenet_data.get('predictions') else 'unknown'
                  ]
                  
                  consensus_prediction = max(set(predictions), key=predictions.count)
                  
                  confidences = [
                      alexnet_data.get('predictions', [{}])[0].get('confidence', 0) if alexnet_data.get('predictions') else 0,
                      resnet_data.get('predictions', [{}])[0].get('confidence', 0) if resnet_data.get('predictions') else 0,
                      mobilenet_data.get('predictions', [{}])[0].get('confidence', 0) if mobilenet_data.get('predictions') else 0
                  ]
                  avg_confidence = sum(confidences) / len(confidences) if confidences else 0
                  
                  image_id = context.get('image_id', 'unknown')
                  
                  table = dynamodb.Table(os.environ['DYNAMODB_TABLE'])
                  
                  table.update_item(
                      Key={'image_id': image_id},
                      UpdateExpression='SET #status = :status, #results = :results, #updated_at = :updated_at',
                      ExpressionAttributeNames={
                          '#status': 'status',
                          '#results': 'classification_results',
                          '#updated_at': 'updated_at'
                      },
                      ExpressionAttributeValues={
                          ':status': 'classified',
                          ':results': {
                              'consensus_prediction': consensus_prediction,
                              'average_confidence': avg_confidence,
                              'model_results': aggregated_results,
                              'classification_timestamp': datetime.utcnow().isoformat()
                          },
                          ':updated_at': datetime.utcnow().isoformat()
                      }
                  )
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Classification results aggregated successfully',
                          'consensus_prediction': consensus_prediction,
                          'average_confidence': avg_confidence,
                          'model_results': aggregated_results,
                          'image_id': image_id
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Environment:
        Variables:
          DYNAMODB_TABLE: !Ref DynamoDBTableName

Outputs:
  ImageIngestionFunctionArn:
    Description: ARN of the image ingestion Lambda function
    Value: !GetAtt ImageIngestionFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-ImageIngestionFunctionArn'

  FetchImageFunctionArn:
    Description: ARN of the fetch image Lambda function
    Value: !GetAtt FetchImageFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-FetchImageFunctionArn'

  PreprocessingFunctionArn:
    Description: ARN of the preprocessing Lambda function
    Value: !GetAtt PreprocessingFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-PreprocessingFunctionArn'

  AlexNetInferenceFunctionArn:
    Description: ARN of the AlexNet inference Lambda function
    Value: !GetAtt AlexNetInferenceFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-AlexNetInferenceFunctionArn'

  ResNetInferenceFunctionArn:
    Description: ARN of the ResNet inference Lambda function
    Value: !GetAtt ResNetInferenceFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-ResNetInferenceFunctionArn'

  MobileNetInferenceFunctionArn:
    Description: ARN of the MobileNet inference Lambda function
    Value: !GetAtt MobileNetInferenceFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-MobileNetInferenceFunctionArn'

  AggregatorFunctionArn:
    Description: ARN of the aggregator Lambda function
    Value: !GetAtt AggregatorFunction.Arn
    Export:
      Name: !Sub '${ProjectName}-AggregatorFunctionArn'
